/* eslint-env webextensions */
/* global Settings, validate */
;(() => {
  'use strict'
  /**
   * Open the user's saved pages for the day when the button is clicked.
   */
  async function openPages (clickedTab) {
    // Pages have bit flags set for each day: Sunday = 1 (1 << 0), Saturday = 64 (1 << 6)
    const today = 1 << new Date().getDay()
    const stored = await browser.storage.sync.get({
      order: [],
      pages: {},
      view: 'days',
      options: {
        randomize: false,
        shouldCloseTabs: true,
        closeTabs: 'newtab',
        openAsPinned: false,
        skipOpen: false,
        skipWindow: 'active',
        reloadOpen: false,
        reloadTabs: 'all'
      },
      // REMOVE in future - v1.0.1 legacy options
      randomize: null,
      closeTabs: null
    })

    const options = stored.options
    let settings = new Settings(stored.pages, stored.order)
    const qcUrls = settings.order
    const qcTabs = []

    // REMOVE in future - v1.0.1 options compatibility
    if (typeof stored.randomize === 'boolean') {
      options.randomize = stored.randomize
      browser.storage.sync.remove('randomize')
      browser.storage.sync.set({options}).catch(console.error)
    }
    if (typeof stored.closeTabs === 'boolean') {
      options.shouldCloseTabs = stored.closeTabs
      browser.storage.sync.remove('closeTabs')
      browser.storage.sync.set({options}).catch(console.error)
    }
    // Randomize order of pages
    if (options.randomize) {
      for (let i = qcUrls.length - 1; i > 0; i -= 1) {
        const j = Math.random() * (i + 1) | 0
        ;[qcUrls[i], qcUrls[j]] = [qcUrls[j], qcUrls[i]]
      }
    }
    if (options.skipOpen) {
      const search = {
        // `false` triggers filtering, `null` does not
        currentWindow: options.skipWindow === 'active' || null
      }
      const tabs = await browser.tabs.query(search)
      const toReload = []
      for (const tab of tabs) {
        const idx = qcUrls.indexOf(tab.url)
        if (idx > -1) {
          toReload.push(tab)
          qcTabs.push(tab)
          qcUrls.splice(idx, 1)
        }
      }
      if (options.reloadOpen) {
        const o = options.reloadTabs
        for (const tab of toReload) {
          if (o === 'all' || (o === 'pinned' && tab.pinned) || (o === 'unpinned' && !tab.pinned)) {
            browser.tabs.reload(tab.id)
          }
        }
      }
    }
    // Close open tabs
    if (options.shouldCloseTabs) {
      const openTabs = await browser.tabs.query({currentWindow: true})
      browser.tabs.remove(openTabs.map(tab => tab.id))
    }
    // Open pages, with error handling only once all tabs are open
    const pages = settings.getPages(today)
    const result = await Promise.all(pages.map(page => {
      // Convert rejection errors into resolved objects with `error` property to allow all errors
      // to be seen, instead of just the first one rejected
      return browser.tabs.create({url: page}).catch(e => ({error: e}))
    }))
    const errors = []
    for (const res of result) {
      if (res.error) errors.push(res.error)
    }
    if (errors.length) handleOpenErrors(errors)
  }

  /**
   * Show an error message when `tabs.create` fails to open a page.
   * @param {Array.Error} errors - Array of errors generated by `tabs.create`
   */
  function handleOpenErrors (errors) {
    browser.browserAction.setPopup({popup: browser.extension.getURL('popup/popup.html')})
    browser.browserAction.setBadgeText({text: '!'})
    browser.storage.local.set({errors: errors.map(validate.translateError)})
  }

  browser.browserAction.onClicked.addListener(e => openPages(e).catch(console.error))
})()
